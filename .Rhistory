# nurses.txt
# Group the dataset by "colony" and sample rows based on "status"
# metadata_GROUPs_seed <- metadata_GROUP %>%
#   group_by(colony) %>%
#   sample_n(ifelse(status == "Big", 18, 3)) %>% # replace FALSE means do not resample rows if threre are less than N to be sliced
#   ungroup()
}else{
metadata_GROUPs_seed <- metadata_GROUP %>%
group_by(colony) %>%
sample_n(first(N_exposed_alive)) %>%  # wondering if it should be random or whether we are better of sampling the first rows?
ungroup()
}
metadata_GROUPs_seed <- metadata_GROUPs_seed[,c("colony_id","tagIDdecimal","treatment_simple","AntTask1perc")]
names(metadata_GROUPs_seed)[which(names(metadata_GROUPs_seed)=="colony_id")] <- "colony"
names(metadata_GROUPs_seed)[which(names(metadata_GROUPs_seed)=="treatment_simple")] <- "treatment"
names(metadata_GROUPs_seed)[which(names(metadata_GROUPs_seed)=="tagIDdecimal")] <- "tag"
metadata_GROUPs_seed <- metadata_GROUPs_seed %>%
mutate(REP_treat = paste0(colony, "_", treatment))
write.table(metadata_GROUPs_seed, file = file.path(SAVEDIR,paste0("seeds/",GROUP,"s.txt")), append = F, col.names = T, row.names = F, quote = F, sep = "\t")
}
metadata_present
metadata_colony <- metadata_present[,c("colony_id","treatment_simple","box","colony_size","REP_treat")]
metadata_colony <- unique(metadata_colony)
metadata_colony <- metadata_present[,c("colony_id","treatment_simple","box","colony_size")]
metadata_colony <- unique(metadata_colony)
metadata_colony
metadata_colony <- metadata_colony %>%
mutate(REP_treat = paste0(colony, "_", treatment))
metadata_colony <- metadata_colony %>%
mutate(REP_treat = paste0(colony_id, "_", treatment))
metadata_colony
metadata_colony <- metadata_colony %>%
mutate(REP_treat = paste0(colony_id, "_", treatment_simple))
metadata_colony
info <- data.frame(colony = metadata_colony$colony_id,
treatment = metadata_colony$treatment_simple,
box = metadata_colony$box,
colony_size = metadata_colony$colony_size,
Ynestmin = NA,
Ynestmax = NA,
nb_larvae = NA,
nb_pupae = NA,
colony_age = NA,
REP_treat= metadata_colony$REP_treat)
write.table(info, file = file.path(SAVEDIR,"info.txt"), append = F, col.names = T, row.names = F, quote = F, sep = "\t")
head(metadata_present)
bead_file <- metadata_present
names(bead_file)[which(names(bead_file)=="colony_id")] <- "colony"
names(bead_file)[which(names(bead_file)=="treatment_simple")] <- "treatment"
names(bead_file)[which(names(bead_file)=="tagIDdecimal")] <- "tag"
bead_file <- bead_file %>% mutate(REP_treat = paste0(colony, "_", treatment))
bead_file <- bead_file %>% mutate(age = NA)
bead_file <- bead_file %>% mutate(status = IsTreated)
names(bead_file)
head(bead_file)
metadata_present
bead_file <- metadata_present
names(bead_file)[which(names(bead_file)=="treatment_simple")] <- "treatment"
names(bead_file)[which(names(bead_file)=="tagIDdecimal")] <- "tag"
bead_file <- bead_file %>% mutate(REP_treat = paste0(colony, "_", treatment))
bead_file <- metadata_present  %>% select(-treatment)
names(bead_file)[which(names(bead_file)=="treatment_simple")] <- "treatment"
names(bead_file)[which(names(bead_file)=="tagIDdecimal")] <- "tag"
bead_file <- bead_file %>% mutate(REP_treat = paste0(colony, "_", treatment))
bead_file <- bead_file %>% mutate(age = NA)
bead_file <- bead_file %>% mutate(status = IsTreated)
bead_file
write.table(bead_file, file = file.path(SAVEDIR,"beads","bead_file.txt"), append = F, col.names = T, row.names = F, quote = F, sep = "\t")
SAVEDIR
bead_file_path <- file.path(SAVEDIR, "beads", "bead_file.txt")
!file.exists(dirname(bead_file_path))
dirname(bead_file_path)
#save
bead_file_path <- file.path(SAVEDIR, "beads", "bead_file.txt")
if (!file.exists(dirname(bead_file_path))) {dir.create(dirname(bead_file_path), recursive = TRUE)}
write.table(bead_file, file = bead_file_path, append = F, col.names = T, row.names = F, quote = F, sep = "\t")
files_list <- list.files(DATADIR)
files_list
files_list <- list.files(DATADIR)
files_list <- list.files(DATADIR, pattern="CapsuleDef2018.myrmidon")
files_list <- files_list[which(!grepl("c29",files_list))]
files_list
file <- files_list[1]
file
colony_id <- unlist(strsplit(file,split="_"))[grepl("c",unlist(strsplit(file,split="_")))]
colony_id
source(paste0(SCRIPTDIR,"/vital_meta_data.R")) # will add colony_metadata data frame to the environment so it can be accessed within this script (in my case containing bodylenght information)
View(metadata_colonies)
View(metadata_colonies)
colony <- colony_id
colony
file <- files_list[1]
l
colony_id <- unlist(strsplit(file,split="_"))[grepl("c",unlist(strsplit(file,split="_")))]
colony <- colony_id
colony
# get base info for this colony
treatment <- colony_metadata[which(colony_metadata$colony_id==colony_id),"treatment_simple"]
treatment
REP_treat <- paste(treatment, tracking_system, colony_id, sep="_")
colony_status <- treatment
print(paste(REP_treat,colony,treatment_code,sep=" | ")) ##}}
# get base info for this colony
treatment <- colony_metadata[which(colony_metadata$colony_id==colony_id),"treatment_simple"]
tracking_system <-colony_metadata[which(colony_metadata$colony_id==colony_id),"tracking_system_main"]
REP_treat <- paste(treatment, tracking_system, colony_id, sep="_")
colony_status <- treatment
print(paste(REP_treat,colony,treatment_code,sep=" | ")) ##}}
print(paste(REP_treat,colony,treatment,sep=" | ")) ##}}
e <- fmExperimentOpen(file)
e
file
getwd()
paste(DATADIR,file, sep = "/")
e <- fmExperimentOpen(paste(DATADIR,file, sep = "/"))
exp.Ants  <- e$ants
names(colony_metadata)
exp_end   <- colony_metadata[which(colony_metadata$colony_id==colony_id),"time_treatment_end"]#fmQueryGetDataInformations(e)$end
treatment_start <- colony_metadata[which(colony_metadata$colony_id==colony_id),"time_treatment_start"]#fmQueryGetDataInformations(e)$start
treatment_start
exp_end   <- colony_metadata[which(colony_metadata$colony_id==colony_id),"time_treatment_end"]#fmQueryGetDataInformations(e)$end
treatment_start <-  as.POSIXct(colony_metadata[which(colony_metadata$colony_id==colony_id),"time_treatment_start"], format="%Y-%m-%dT%H:%M:%OSZ",  origin="1970-01-01", tz="GMT" ) #fmQueryGetDataInformations(e)$start
treatment_start
exp_start <- treatment_start- 24*3600
exp_start
exp_start <- fmTimeCreate(treatment_start-24*3600)
exp_start
tag_stats <- fmQueryComputeTagStatistics(e)
ant <- exp.Ants[[1]]
ant
all(ant$getValues("IsAlive")["values"]$values)
id <- ant$identifications[[1]]
ant$ID,
ant$ID
tag_stats[which(tag_stats$tagDecimalValue == id$tagValue),"count"]
round(as.numeric(difftime(tag_stats[which(tag_stats$tagDecimalValue == id$tagValue),"lastSeen"],exp_start,units="secs"))*FRAME_RATE)
27*3600*FRAME_RATE
tag_stats[which(tag_stats$tagDecimalValue == id$tagValue),"lastSeen"]
### THIS EXCLUDES THE ANTS WITH ROTATED TAGS! if (capture.output(ant$identifications[[1]]$end)=="+âˆž") {      ### this was probably in andrianos but not needed by linda, kept for now so it could get back in should I need it?
tag_file <- rbind(tag_file,data.frame(tag =  ant$ID,
count = tag_stats[which(tag_stats$tagDecimalValue == id$tagValue),"count"],
# version 1:
last_det = 27*3600*FRAME_RATE #not entirely clear: simple like adriano: last_det = 51*60*60 * 8, #fixed= sll alive, so it is the n of frames for 51 hours.tag_stats[which(tag_stats$tagDecimalValue == id$tagValue),"lastSeen"],tag_stats[which(tag_stats$tagDecimalValue == id$tagValue),"lastSeen"],
# version 2: number of frames since official starting of tracking 24 h before treatment until last seen?
last_det = round(as.numeric(difftime(tag_stats[which(tag_stats$tagDecimalValue == id$tagValue),"`lastSeen"], treatment_start-24*3600, units="secs"))*FRAME_RATE),
last_det = round(as.numeric(difftime(tag_stats[which(tag_stats$tagDecimalValue == id$tagValue),"`lastSeen"],exp_start,units="secs"))*FRAME_RATE), #L: what duration should be used here? filming? pre + post? for now filming 24 h + (12 h - 1.5 h) = 34.5 h (plus buffer of 0.5 h in case filming was put on a bit earlier?) with 8 fps
rot = round(deg(id$antAngle),3), # assumed to be the the relative angle of the ant to the tag
displacement_distance = 0, #id$antPosition one of the two measures
displacement_angle = 0,
antenna_reach = NA,
trapezoid_length = NA,
type = "N", #what does it mean?
size = 0 ,
headwidth = 0,
death = 0,  #all alive, dead not included
age = 0,
final_status = ifelse(metadata_present[which(metadata_present$tagIDdecimal == id$tagValue & metadata_present$REP_treat==REP_treat),"IsAlive"]==T,"alive","dead"),
group = metadata_present[which(metadata_present$tagIDdecimal == id$tagValue & metadata_present$REP_treat==REP_treat),"AntTask1perc"],
REP_treat = REP_treat,
stringsAsFactors = F))
round(as.numeric(difftime(tag_stats[which(tag_stats$tagDecimalValue == id$tagValue),"`lastSeen"], treatment_start-24*3600, units="secs"))*FRAME_RATE)
treatment_start-24*3600
tag_stats[which(tag_stats$tagDecimalValue == id$tagValue),"`lastSeen"]
tag_stats
tag_stats[which(tag_stats$tagDecimalValue == id$tagValue),"lastSeen"]
round(as.numeric(difftime(tag_stats[which(tag_stats$tagDecimalValue == id$tagValue),"lastSeen"], treatment_start-24*3600, units="secs"))*FRAME_RATE)
27*3600*FRAME_RATE
rm(list = ls())
gc()
Sys.sleep(3)
mallinfo::malloc.trim(0L)
### input parameters:
library(tcltk)
FRAME_RATE <- 6
# Define which interactions to look at:
{
RUN_CLASSIC_INTERACTIONS           <- FALSE
RUN_GROOMING_INTERACTIONS          <- FALSE
RUN_TROPHALLACTIC_INTERACTIONS     <- TRUE
# Define what analysis step to run:
RUN_11_randomise_interactions_DS.R        <- FALSE
RUN_12_simulate_transmission_DS.R         <- TRUE
RUN_13_network_analysis_DS.R              <- FALSE
RUN_14_summarise_interactions_DS.R        <- FALSE
RUN_19_Facetnet_community_detection_DS.R  <- FALSE
}
getwd()
setwd(tk_choose.dir(default = "~/", caption = "Select Working Directory")) # direct it to where you have config_user_and_hd.R (typically the script folder or github folder)
getwd()
setwd("/home/ael/Documents/vital_rscripts_git")
#setwd(tk_choose.dir(default = "~/", caption = "Select Working Directory")) # direct it to where you have config_user_and_hd.R (typically the script folder or github folder)
source("config_user_and_hd.R") # contains getUserOptions() that defines usr and hd and the clean() function
# additional functions
choose_data_path <- function() { # does not work on the mac.
list(
CLASSIC_INTERACTIONS = if (RUN_CLASSIC_INTERACTIONS) paste("/media", usr, hd, "vital/fc2/vital_experiment/main_experiment", sep="/") else NULL,
GROOMING_INTERACTIONS = if (RUN_GROOMING_INTERACTIONS) paste("/media", usr, hd, "vital/fc2/vital_experiment/main_experiment_grooming", sep="/") else NULL,
TROPHALLACTIC_INTERACTIONS = if (RUN_TROPHALLACTIC_INTERACTIONS) paste("/media", usr, hd, "vital/fc2/vital_experiment/main_experiment_trophallaxis", sep="/") else NULL
)
}
# get the data and script paths as well as additional info tables, libraries, parameters and functions loaded:
code_path   <- paste("/home/",usr,"/Documents/vital_rscripts_git/source_scripts",sep="") # place where the needed r scripts are stored
data_paths  <- choose_data_path()
info        <- read.table(paste("/media", usr, hd, "vital/fc2/vital_experiment/main_experiment/original_data/info.txt",sep="/"), header=T,stringsAsFactors = F)
treated     <- read.table(paste("/media", usr, hd, "vital/fc2/vital_experiment/main_experiment/original_data/treated_worker_list.txt",sep="/"),header=T,stringsAsFactors = F)
task_groups <- read.table(paste("/media", usr, hd, "vital/fc2/vital_experiment/main_experiment/original_data/task_groups.txt",sep="/"),header=T,stringsAsFactors = F) # might need to be checked if this how the task groups are defined at the moment... % or facet net?
tag_list    <- paste("/media", usr, hd, "vital/fc2/vital_experiment/main_experiment/original_data/tag_files/",sep="/")
seed_path   <- paste("/media", usr, hd, "vital/fc2/vital_experiment/main_experiment/original_data/seeds/",sep="/")
splitpath   <- paste("/media", usr, hd, "vital/fc2/vital_experiment/main_experiment/original_data/time_aggregation_info/",sep="/")
split_list  <- paste(splitpath,list.files(splitpath),sep="") # needed for transmission simulation
high_threshold <- 0.0411 * 0.5/0.3 # Science paper: high threshold =0.0411 where 1 = load of treated   # In Adriano's experiment, spore concentration was the same but volume was 0.3 microliter instead of 0.5 microliter --> needs to be adjusted so that it fits the virus or bead data (CHECK WHAT LUKE DID HERE?)
to_keep <- c(ls(),"to_keep", "loop_start_time")
if (RUN_11_randomise_interactions_DS.R){
print("running 11_randomise_interactions_DS.R")
for (interaction_type in names(data_paths)) {
data_path <- data_paths[[interaction_type]]
if (!is.null(data_path)) {
print(paste("Processing file for", interaction_type, "\U0001F91D"))
source(paste(code_path,"/11_randomise_interactions_DS.R",sep=""))
clean()
}
print(paste("ALL DONE", "\U0001F973"))
}} else {print("skipping 11_randomise_interactions_DS.R")}
print("running 12_simulate_transmission_DS.R")
interaction_type <- "TROPHALLACTIC_INTERACTIONS"
data_path <- data_paths[[interaction_type]]
print(paste("Processing files for", interaction_type, "\U0001F91D"))
to_keep_ori <- to_keep
Sys.setenv("PKG_CXXFLAGS"="-std=c++11")
sourceCpp(paste(code_path,"/simulate_transmission.cpp",sep=""))
loop_start_time <- Sys.time()
### ### ### ### ### ### ### ### ### ### ###
options(digits=16) ; options(digits.secs=6) ; options("scipen" = 10)
#### get input file list
input_path         <- paste(data_path,"/intermediary_analysis_steps/full_interaction_lists",sep="")
setwd(input_path)
input_files        <- paste(input_path,"/",list.files(recursive=T,pattern="interactions"),sep="")
#### arguments
N_SIM  <- 500 # N_SIM  <- 1
!grepl("survival",data_path)
seed_files <- c("treated_workers.txt","random_workers.txt","foragers.txt","nurses.txt")
to_keep <- c(ls(),"to_keep","seed_file","outputfolder","interac_folders","interac_folder","interac_list","summary_collective","summary_individual","interac", "loop_start_time")
seed_file <- "treated_workers.txt"
!grepl("survival",data_path)
#if (!grepl("survival",data_path)){
outputfolder    <- paste(data_path,"/transmission_simulations/pre_vs_post_treatment/experimentally_exposed_seeds",sep="")
interac_folders <- "observed"
if (!file.exists(outputfolder)){dir.create(outputfolder,recursive = T)}
interac_folder <- "observed"
if (interac_folder!="observed"){interac_folder <- paste("random_",paste(rep(0,3-nchar(interac_folder)),collapse=""),interac_folder,sep="")}
!file.exists(paste(outputfolder,"/individual_simulation_results_",interac_folder,".txt",sep=""))
outputfolder
if (!file.exists(outputfolder)){dir.create(outputfolder,recursive = T)}
!file.exists(paste(outputfolder,"/individual_simulation_results_",interac_folder,".txt",sep=""))
summary_collective <- NULL
summary_individual <- NULL
interac_list <- input_files[grepl(interac_folder,input_files)]
if (seed_file!="treated_workers.txt"){interac_list <- interac_list[grepl("PreTreatment",interac_list)]}
interac_list
interac  <- interac_list[33]
print(interac)
### get colony info
root_name          <- file_name <- basename(interac)
colony             <- unlist(strsplit(root_name, split="_"))[1]
treatment          <- unlist(strsplit(root_name, split="_"))[2]
period_detail      <- sub("(.*)Treatment.*", "\\1", unlist(strsplit(root_name,split="_"))[3]) # pre post?
colony
treatment
period_detail
if (grepl("Pre",root_name)){period="before"}else{period="after"}
### read interactions
interaction_table <- read.table(interac,header=T,stringsAsFactors=F,sep = "\t")
interaction_table <- interaction_table[order(interaction_table$Starttime),]
interaction_table <- interaction_table[which(!duplicated(interaction_table)),] # would remove duplicates
### DS: additional checks because the trophallaxis interaction_table is missing some columns that were not created due to my simplified design with only 1 3h block to analyze - technically not required but easier with subsequent scripts
if (!"time_hours" %in% colnames(interaction_table)) {# Check if 'interaction_table' contains the column 'time_hours'
interaction_table$time_hours <- ifelse(period == "before", -24, ifelse(period == "after", 0, NA)) # Create and fill 'time_hours' based on the value of 'period'
}
if (!"time_of_day" %in% colnames(interaction_table)) { # Check if 'interaction_table' contains the column 'time_of_day'
interaction_table$time_of_day <- 11  # Create and fill 'time_of_day' with the value 11
}
### get appropriate task_group list
colony_task_group  <- task_groups[which(task_groups$colony==colony),] # contains both task group types i.e. percentage and facet net based
queenid            <- as.character(colony_task_group[which(colony_task_group$task_group_prop=="queen"),"tag"]) #call specific queen tag instead of fixed 665. it has to be a character to work with igraph, technically could be just set to to "1" if appropriate queen tags were used during tagging
### read tag list to define list of live ants: get tag list for colony and filter out alive ones.
tag <- read.tag(tag_list, colony) # function defined in main analysis
#if (!grepl("survival",data_path)){ # for DS never survival so  simplified here...
alive      <- tag[which(tag$final_status=="alive"),"tag"]
# }else{
#   alive      <- tag[which(as.numeric(tag$death)==0|as.numeric(tag$death)>=max(interaction_table$Stopframe,na.rm=T)),"tag"]
# }
#
### make sure interaction table only contains ants that were alive the end
if (!all(unique(c(interaction_table$Tag1,interaction_table$Tag2))%in%alive)){
print(paste("Warning: In ", basename(interac)," ant ",unique(c(interaction_table$Tag1,interaction_table$Tag2))[which(!unique(c(interaction_table$Tag1,interaction_table$Tag2))%in%alive)], " is present in interaction table but is not alive according to tag_list!"))
print("interaction list will be subsetted to alive ants only")
interaction_table <- interaction_table[which(interaction_table$Tag1%in%alive & interaction_table$Tag2%in%alive),]
}
print("interaction list gets subsetted to only contain ants alive until the end")
### read seeds
seeds              <- read.table(paste(seed_path,seed_file,sep=""),header=T,stringsAsFactors = F)
seeds              <- seeds[which(seeds$colony==colony),"tag"]
seeds              <- seeds[which(seeds%in%alive)]
### read time aggregation info for both current file and PostTreatment file if relevant (i.e. if reorder=T), and get start time from that
# DS: I never have survival and as linda do not have reorder either
#if (!grepl("survival",data_path)){
splitfile          <- split_list[grepl(sub("(.*Treatment).*", "\\1", root_name),split_list)]
splitinfo          <- read.table(splitfile,header=T,stringsAsFactors = F)
# LS: I don't have "reorder" (would always be FALSE anyway) so following statement was commented out
# if (reorder){
#   splitfile_Post   <- split_list[grepl(gsub("Pre","Post",root_name),split_list)]
#   splitinfo_Post   <- read.table(splitfile_Post,header=T,stringsAsFactors = F)
# }
time_start         <- min(splitinfo$time,na.rm=T)
### Create antlist object
antlist                                                 <- data.frame(tag=alive,status=0,load=0,stringsAsFactors = F)
antlist[which(antlist$tag%in%seeds),c("status","load")] <- 1
### Change formats to match formats expected by the C++ program
antlist$tag                                             <- as.integer(antlist$tag )
antlist$status                                          <- as.integer(antlist$status )
antlist$load                                            <- as.numeric(antlist$load )
interaction_table$Tag1                                  <- as.integer(interaction_table$Tag1 )
interaction_table$Tag2                                  <- as.integer(interaction_table$Tag2 )
interaction_table$Startframe                            <- as.integer(interaction_table$frame_start )
interaction_table$Stopframe                             <- as.integer(interaction_table$frame_stop )
interaction_table$Starttime                             <- as.numeric(interaction_table$Starttime )
interaction_table$Stoptime                              <- as.numeric(interaction_table$Stoptime )
# create vector of names matching the interac_folder format
interac_folders_named <- ifelse(interac_folders != "observed",sprintf("random_%03d", as.numeric(interac_folders)),interac_folders) # first element will be "observed" rest "random_001" and so forth...
#### Perform simulations ####
print("Performing simulations...")
simulations <- NULL
N_SIM
for (i in 1:N_SIM){ # i=1
simulations <- rbind(simulations,data.frame(sim_number=i,simulate_transmission(i_table=interaction_table,ant_list=antlist,t0=time_start,seed=i*which(seed_file==seed_files)*which(interac_folder==interac_folders_named)*which(interac==interac_list),frame_rate=FRAME_RATE)))
# Sys.sleep(1)
# gc()
}
#### Step 1: modify columns ####
simulations$relative_contamination_time                      <- simulations$relative_contamination_time/3600 # express contamination time in hours instead of seconds
simulations                                                  <- simulations[,!names(simulations)%in%c("absolute_contamination_time","infectious")] # remove unncessary columns
simulations["contaminated"]                                  <- 1          # add a column containing information on whether the ant was contaminated or not during the simulation
simulations["status"]                                        <- "untreated"
simulations[which(simulations$tag%in%seeds),"status"]        <- "treated"
#### Step 2: add individuals that did not get contaminated during the simulations ####
all_individuals <- expand.grid(sim_number=c(1:N_SIM),tag=alive)
simulations     <- merge(all_individuals,simulations,all.x=T,all.y=T)
if (nrow( simulations[which(is.na(simulations$relative_contamination_time)),])>0){
simulations[which(is.na(simulations$relative_contamination_time)),"status"]     <- "untreated"
simulations[which(is.na(simulations$relative_contamination_time)),c("relative_contamination_time","contaminated_by","final_load","contaminated")]     <- rep(c(24,-1,0,0) ,each=nrow(simulations[which(is.na(simulations$relative_contamination_time)),]))
}
simulations     <- simulations[order(simulations$sim_number,simulations$relative_contamination_time),]
#### Step3: add further individual-level information ####
# Add infection rank
ranks <- aggregate(relative_contamination_time~sim_number,function(x)rank(x,ties.method="min"),data=simulations[which(simulations$status!="treated"),])
for (sim_number in unique(ranks$sim_number)){ #sim_number <- 1
simulations[which(simulations$sim_number==sim_number&simulations$status=="treated"),"rank"] <- 0
simulations[which(simulations$sim_number==sim_number&simulations$status!="treated"),"rank"] <- as.numeric(ranks[which(ranks$sim_number==sim_number),c(2:ncol(ranks))])
}
# Add high load/low load
simulations["high_level"] <- as.numeric(simulations$final_load>high_threshold)
simulations["low_level"] <- as.numeric(simulations$final_load>0&simulations$final_load<=high_threshold)
#### Step 4.1: Prevalence, Mean load, Prop. high level, Prop. low level, Mean load ####
colony_level         <- aggregate(na.rm=T,na.action="na.pass",cbind(contaminated,final_load,high_level,low_level)~sim_number,FUN=mean,data=simulations[which(simulations$status!="treated"),])
names(colony_level)  <- c("sim_number","Prevalence","Mean_load","Prop_high_level","Prop_low_level")
#### Step 4.2: Load skewness ####
skewness             <- aggregate(na.rm=T,na.action="na.pass",final_load~sim_number,FUN=skewness,data=simulations[which(simulations$status!="treated"),]) # LS: only works if object "skewness" does not exist yet, when re-running this line during testing an error will occur -> rm(ls = skewness)
names(skewness)      <- c("sim_number","Load_skewness")
colony_level         <- merge(colony_level,skewness)
# Step 4.3: Queen load
queen                <- simulations[which(simulations$tag==queenid),c("sim_number","final_load")]
names(queen)         <- c("sim_number","Queen_load")
colony_level         <- merge(colony_level,queen)
#### Step 4.4: Transmission rate ####
colony_level["logistic_r"] <- NA
sim <- 1
# define table that will be used in the non linear fit
subset <- simulations[which(simulations$sim_number==sim),]
# remove from subset the ants that were not infected during the simulation and were added later
subset <- subset[which(subset$contaminated!=0),]
# sort by time
subset <- subset[order(subset$relative_contamination_time,subset$status),]
# get population size
pop_size <- sum(subset[1,c("nb_susceptible","nb_contaminated")])
#get relevant data
spread                 <- subset[c("relative_contamination_time","rank")]
spread["nb_seeds"]     <- nrow(subset[which(subset$status=="treated"),])
spread["nb_contaminated"] <- spread$rank+spread$nb_seeds
spread <- spread[which(!duplicated(spread[c("relative_contamination_time","nb_contaminated")])),]
spread["proportion_contaminated"] <- spread$nb_contaminated/pop_size
# try logistic fit
y <- spread$proportion_contaminated
x <- spread$relative_contamination_time
P_zero <- spread[which(spread$rank==0),"proportion_contaminated"]
# K <- 1
if (exists("fit_logistic")){rm(list=c("fit_logistic"))}
try(fit_logistic <- nls(
y ~ (K*P_zero*exp(r*x))
/
(K+(P_zero*(-1+exp(r*x))))
,
start=list(r=1,K=1)
#start=list(r=1)
,
control=list(maxiter = 1000)
)
,silent=T)
if (exists("fit_logistic")){
r <- summary(fit_logistic)$coefficients["r","Estimate"]
K <- summary(fit_logistic)$coefficients["K","Estimate"]
colony_level[which(colony_level$sim_number==sim),"logistic_r"] <- r
}
rm(list=c("fit_logistic","r","K"))
#### Step 4.5: Take average over all simulations ####
colony_level         <- colMeans(colony_level[names(colony_level)!="sim_number"],na.rm=T)
#### Step 4.6: Store ####
summary_collective   <- rbind(summary_collective, cbind(data.frame(colony=colony,
colony_size=info[which(info$colony==colony),"colony_size"],
treatment=info[which(info$colony==colony),"treatment"],
period=period,
period_detail=period_detail,
time_hours=interaction_table[1,"time_hours"],
time_of_day=interaction_table[1,"time_of_day"],
stringsAsFactors = F),
t(colony_level)))
#### Step 5.1: Final_load, Prob. contamination, Prob. high level, Prob. low level ####
individual_level         <- aggregate(na.rm=T,na.action="na.pass", cbind(final_load,contaminated,high_level,low_level) ~ tag,FUN=mean,data=simulations)
names(individual_level)  <- c("tag","simulated_load","probability_of_transmission","probability_high_level","probability_low_level")
#### Step 5.2: Transmission latency and transmission rank ####
individual_level[c("transmission_latency","transmission_rank")] <- NA
for (ant in alive){
if (all(simulations[which(simulations$tag==ant),"contaminated"]==1)){
individual_level[which(individual_level$tag==ant),"transmission_latency"] <- mean(simulations[which(simulations$tag==ant),"relative_contamination_time"])
individual_level[which(individual_level$tag==ant),"transmission_rank"]    <- mean(simulations[which(simulations$tag==ant),"rank"])
}else{
# transmission latency
model                                                                     <- coxph(Surv(relative_contamination_time,contaminated)~1,data=simulations[which(simulations$tag==ant),])
mean_data                                                                 <- summary(survfit(model),rmean="common")$table
individual_level[which(individual_level$tag==ant),"transmission_latency"] <-  mean_data["rmean"] # LS: column name changed to "rmean"
# transmission rank
model                                                                     <- coxph(Surv(rank,contaminated)~1,data=simulations[which(simulations$tag==ant),])
mean_data                                                                 <- summary(survfit(model),rmean="common")$table
individual_level[which(individual_level$tag==ant),"transmission_rank"]    <-  mean_data["rmean"] # LS: column name changed to "rmean"
}
}
#### Step 5.3: Store ####
individual_level$antid          <- as.character(interaction(colony,individual_level$tag))
individual_level$status         <- "untreated";individual_level[which(individual_level$tag%in%seeds),"status"] <- "treated"
individual_level["colony"]      <- colony
individual_level["colony_size"] <- info[which(info$colony==colony),"colony_size"]
individual_level["treatment"]   <- info[which(info$colony==colony),"treatment"]
individual_level["period"]      <- period
individual_level["period_detail"]      <- period_detail
individual_level["time_hours"]  <- interaction_table[1,"time_hours"]
individual_level["time_of_day"] <- interaction_table[1,"time_of_day"]
individual_level       <- individual_level[c("colony","colony_size","treatment","tag","antid","status","period","period_detail",
"time_hours","time_of_day","simulated_load","probability_of_transmission","probability_high_level",
"probability_low_level","transmission_latency","transmission_rank")]
summary_individual     <- rbind(summary_individual,individual_level)
clean()
#ordering based on time hours.
summary_collective <- summary_collective[order(summary_collective$colony,summary_collective$time_hours),]
summary_individual <- summary_individual[order(summary_individual$colony,summary_individual$tag,summary_individual$time_hours),]
if (grepl("random_vs_observed",outputfolder)){
summary_collective["randy"] <- interac_folder
summary_individual["randy"] <- interac_folder
}
write.table(summary_collective,paste(outputfolder,"/collective_simulation_results_",interac_folder,".txt",sep=""),col.names=T,row.names=F,quote=F,append=F)
write.table(summary_individual,paste(outputfolder,"/individual_simulation_results_",interac_folder,".txt",sep=""),col.names=T,row.names=F,quote=F,append=F)
if (grepl("random_vs_observed",outputfolder )){
setwd(outputfolder)
file_list <- list.files(pattern="individual")
all_indiv_results <- NULL
for (file in file_list){
temp <- read.table(file, header=T,stringsAsFactors = F)
if (grepl("random",unique(temp$randy))){
temp$randy <- "random"
}
all_indiv_results <- rbind(all_indiv_results,temp)
}
all_indiv_results <- aggregate(na.rm=T,na.action="na.pass",cbind(simulated_load,probability_of_transmission,probability_high_level,probability_low_level,transmission_latency,transmission_rank)~.,FUN=mean,data=all_indiv_results)
all_indiv_results$treatment <- all_indiv_results$randy
write.table(all_indiv_results,file=paste(outputfolder,"/summarised_individual_results.dat",sep=""),append=F,quote=F,row.names=F,col.names=T)
}
rm(list = ls())
gc()
Sys.sleep(3)
mallinfo::malloc.trim(0L) # forced memory cleaning after every gc() | # install in terminal: > sudo apt-get install libtcmalloc-minimal4
rm(list = ls())
gc()
Sys.sleep(3)
mallinfo::malloc.trim(0L)
### input parameters:
library(tcltk)
FRAME_RATE <- 6
# Define which interactions to look at:
{
RUN_CLASSIC_INTERACTIONS           <- FALSE
RUN_GROOMING_INTERACTIONS          <- FALSE
RUN_TROPHALLACTIC_INTERACTIONS     <- TRUE
# Define what analysis step to run:
RUN_11_randomise_interactions_DS.R        <- FALSE
RUN_12_simulate_transmission_DS.R         <- TRUE
RUN_13_network_analysis_DS.R              <- FALSE
RUN_14_summarise_interactions_DS.R        <- FALSE
RUN_19_Facetnet_community_detection_DS.R  <- FALSE
}
setwd("/home/ael/Documents/vital_rscripts_git")
#setwd(tk_choose.dir(default = "~/", caption = "Select Working Directory")) # direct it to where you have config_user_and_hd.R (typically the script folder or github folder)
source("config_user_and_hd.R") # contains getUserOptions() that defines usr and hd and the clean() function
tk_choose.dir(default = "~/", caption = "Select Hard Drive")
tk_choose.dir(default = "/media/", caption = "Select Hard Drive")
