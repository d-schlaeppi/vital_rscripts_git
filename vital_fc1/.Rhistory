cluster_cols = FALSE,
color = c("#CCEBC5", "#FBB4AE"),
legend = FALSE,
labels_col = c("Week 1", "Week 2"),
show_rownames = TRUE,
show_colnames = TRUE)
#### 2.7 Plot Nr of ants over time with shifted t0 ####
# instead at counting time for both food sources starting when the first one is discovered we now look at the data with discovery time for each food sources separately
# thereby minimizing effect of first discovery (but not removing it!!!) and showing the initial recruitment to the food sources.
data_shifted <- dynamic_dat_shifted_t0_Nb
data_shifted$time_min <- data_shifted$time/60
data_plot3 <- data_shifted %>% group_by(status, time_min) %>%
summarise(
mean = mean(Nb_ants),
sem = sem(Nb_ants)
) %>% as.data.frame()
ggplot(data = data_plot3, aes(x = time_min, y = mean, color = status)) +
geom_point(size = 2) +
geom_ribbon(aes(ymin=mean-sem, ymax=mean+sem), alpha = 0.2) +
theme_light() +
scale_color_viridis(end = 0.8,
name  ="food source",
breaks=c("healthy", "virus"),
labels=c("control", "virus"),
discrete = TRUE, option = "D") +
ggtitle("                       initial recruitment") +
xlab("time [min]") +
ylab("mean number of ants")
if (RUN_ANALYSIS_AND_SIMULATIONS_NR) {
for (time_origin in c("same","shifted")){ # time_origin <- "same"
### get dynamic data
dynamic_dat_Nb      <- get(paste("dynamic_dat",time_origin,"t0","Nb",sep="_"))
dynamic_dat_Diff    <- get(paste("dynamic_dat",time_origin,"t0","Diff",sep="_"))
### calculate means and SE create dynamic_summary_dat_Nb objects
dynamic_summary_dat_Nb    <- data.frame(as.matrix(aggregate(Nb_ants   ~feeding_session+status+time,function(x)cbind(mean(x),std.error(x)),data=dynamic_dat_Nb)),stringsAsFactors = F)
names(dynamic_summary_dat_Nb)[which(grepl(".1",names(dynamic_summary_dat_Nb)))] <- gsub(".1","_Mean",names(dynamic_summary_dat_Nb)[which(grepl(".1",names(dynamic_summary_dat_Nb)))])
names(dynamic_summary_dat_Nb)[which(grepl(".2",names(dynamic_summary_dat_Nb)))] <- gsub(".2","_SE",names(dynamic_summary_dat_Nb)[which(grepl(".2",names(dynamic_summary_dat_Nb)))])
dynamic_summary_dat_Nb$Nb_ants_Mean <- as.numeric( dynamic_summary_dat_Nb$Nb_ants_Mean)
dynamic_summary_dat_Nb$Nb_ants_SE   <- as.numeric( dynamic_summary_dat_Nb$Nb_ants_SE)
dynamic_summary_dat_Nb <- dynamic_summary_dat_Nb[order(dynamic_summary_dat_Nb$time),]
### calculate means and SE create dynamic_summary_dat_Diff objects
dynamic_summary_dat_Diff    <- data.frame(as.matrix(aggregate(Delta_Nb_ants   ~feeding_session+status+time,function(x)cbind(mean(x),std.error(x)),data=dynamic_dat_Diff)),stringsAsFactors = F)
names(dynamic_summary_dat_Diff)[which(grepl(".1",names(dynamic_summary_dat_Diff)))] <- gsub(".1","_Mean",names(dynamic_summary_dat_Diff)[which(grepl(".1",names(dynamic_summary_dat_Diff)))])
names(dynamic_summary_dat_Diff)[which(grepl(".2",names(dynamic_summary_dat_Diff)))] <- gsub(".2","_SE",names(dynamic_summary_dat_Diff)[which(grepl(".2",names(dynamic_summary_dat_Diff)))])
dynamic_summary_dat_Diff$Delta_Nb_ants_Mean <- as.numeric( dynamic_summary_dat_Diff$Delta_Nb_ants_Mean)
dynamic_summary_dat_Diff$Delta_Nb_ants_SE   <- as.numeric( dynamic_summary_dat_Diff$Delta_Nb_ants_SE)
dynamic_summary_dat_Diff <- dynamic_summary_dat_Diff[order(dynamic_summary_dat_Diff$time),]
### calculate one mean number of ants for each source, each colony and each feeding session
summary_dat_Nb      <- aggregate(Nb_ants   ~colony_id+feeding_session+block+virus_position+discovery_time_virus+discovery_time_healthy+first_source_discovered+status,FUN=mean,data=dynamic_dat_Nb)
### stats
print( paste("Statistics -",time_origin,"T0"))
model <- lmer(Nb_ants ~ status*feeding_session + (1|colony_id) + (1|first_source_discovered), data=summary_dat_Nb )
print(Anova(model))
print(shapiro.test(residuals(model)))
### plot  TO IMPROVE: SHOULD BE MEANS AND STANDARD ERRORS RATHR THAN BOXPLOT
boxplot(Nb_ants~status+feeding_session,data=summary_dat_Nb)
### NOTE: As feeding session is highly non-significant, we don't need to distinguish between the two in the analysis of randomisation tests
### Plot Dynamic data For Each Session
for (session in c(1,2)){ # session <- 1
ymin <- min( dynamic_summary_dat_Nb$Nb_ants_Mean-dynamic_summary_dat_Nb$Nb_ants_SE )
ymax <- max( dynamic_summary_dat_Nb$Nb_ants_Mean+dynamic_summary_dat_Nb$Nb_ants_SE )
plot(Nb_ants_Mean ~ time, pch=16, col="red",
data=dynamic_summary_dat_Nb[which(dynamic_summary_dat_Nb$feeding_session==session & dynamic_summary_dat_Nb$status=="virus"),],
ylim=c(ymin-0.1*(ymax-ymin),ymax+0.1*(ymax-ymin)),bty="l",
main =paste("Session",session,"-", time_origin ,"t0"))
polygon( x= c( dynamic_summary_dat_Nb[which(dynamic_summary_dat_Nb$feeding_session==session & dynamic_summary_dat_Nb$status=="virus"),"time"]
,
rev(dynamic_summary_dat_Nb[which(dynamic_summary_dat_Nb$feeding_session==session & dynamic_summary_dat_Nb$status=="virus"),"time"]) ) ,
y= c( dynamic_summary_dat_Nb[which(dynamic_summary_dat_Nb$feeding_session==session & dynamic_summary_dat_Nb$status=="virus"),"Nb_ants_Mean"] - dynamic_summary_dat_Nb[which(dynamic_summary_dat_Nb$feeding_session==session & dynamic_summary_dat_Nb$status=="virus"),"Nb_ants_SE"]
,
rev( dynamic_summary_dat_Nb[which(dynamic_summary_dat_Nb$feeding_session==session & dynamic_summary_dat_Nb$status=="virus"),"Nb_ants_Mean"] + dynamic_summary_dat_Nb[which(dynamic_summary_dat_Nb$feeding_session==session & dynamic_summary_dat_Nb$status=="virus"),"Nb_ants_SE"])),
col=alpha("red",0.5),border=NA
)
points(Nb_ants_Mean ~ time, pch=16, col="blue",
data=dynamic_summary_dat_Nb[which(dynamic_summary_dat_Nb$feeding_session==session & dynamic_summary_dat_Nb$status=="healthy"),])
polygon(  x= c( dynamic_summary_dat_Nb[which(dynamic_summary_dat_Nb$feeding_session==session & dynamic_summary_dat_Nb$status=="healthy"),"time"]
,
rev(dynamic_summary_dat_Nb[which(dynamic_summary_dat_Nb$feeding_session==session & dynamic_summary_dat_Nb$status=="healthy"),"time"]) ) ,
y= c( dynamic_summary_dat_Nb[which(dynamic_summary_dat_Nb$feeding_session==session & dynamic_summary_dat_Nb$status=="healthy"),"Nb_ants_Mean"] - dynamic_summary_dat_Nb[which(dynamic_summary_dat_Nb$feeding_session==session & dynamic_summary_dat_Nb$status=="healthy"),"Nb_ants_SE"]
,
rev( dynamic_summary_dat_Nb[which(dynamic_summary_dat_Nb$feeding_session==session & dynamic_summary_dat_Nb$status=="healthy"),"Nb_ants_Mean"] + dynamic_summary_dat_Nb[which(dynamic_summary_dat_Nb$feeding_session==session & dynamic_summary_dat_Nb$status=="healthy"),"Nb_ants_SE"])),
col=alpha("blue",0.5),border=NA
)
legend ("topright",legend=c("virus","healthy"),col=c("red","blue"),pch=16,bty="n")
}
### Randomisation test for each session
### Aim: test whether the results are an artifact from virus food tending to be discovered earlier than healthy food
### H0: there is no difference in ant behaviour towards either virus or healthy food, the only relevant point for recruitment is which food was discovered first
### In the observed dataset the virus was discovered first a certain number of time
### The randomisation will consist in randomly drawing the same number of colonies from the total and saying that in these colonies the first source had virus (irrespective of truth), and in all others the first source was healthy irrespective of truth)
### If observed data is an artifact, we should observe a similar difference in number of ants between the two sources in randomised and real data
### Pre-calculations: nb of colonies that found the virus first in each session, and observed difference in number of ants across all colonies and all times
nb_discoveries <- aggregate(colony_id~first_source_discovered+feeding_session ,FUN=length, data= summary_dat_Nb[which(summary_dat_Nb$status=="healthy"),])
observed_Diff    <- aggregate(Delta_Nb_ants   ~ status,FUN=mean,data=dynamic_dat_Diff)
random_data_dynamic_Nb <- NULL
random_data_Diff       <- NULL
for (i in 1 : 1000){ ### randomisation loop # i <- 1
rand_Nb   <- NULL
rand_Diff <- NULL
### randomise separately for each session
for (session in c(1,2)){ # session <- 1
nb_virus       <- nb_discoveries[which(nb_discoveries$first_source_discovered=="virus"&nb_discoveries$feeding_session==session),"colony_id"]
subset_Nb   <- dynamic_dat_Nb[which(dynamic_dat_Nb$feeding_session==session),]
subset_Diff <- dynamic_dat_Diff[which(dynamic_dat_Diff$feeding_session==session),]
colony_list <- unique(subset_Nb$colony_id)
hypothetic_virus_first    <- sample(colony_list,size=nb_virus,replace = F)
### now create first_source_discovered_RAND column according to hypothetical status
rand_subset_Nb                                                                                           <- subset_Nb             ; rand_subset_Diff                                                                                             <- subset_Diff
rand_subset_Nb$first_source_discovered_RAND                                                              <- "healthy"             ; rand_subset_Diff$first_source_discovered_RAND                                                                <- "healthy" ;
rand_subset_Nb[which(rand_subset_Nb$colony_id%in%hypothetic_virus_first),"first_source_discovered_RAND"] <- "virus"               ; rand_subset_Diff[which(rand_subset_Diff$colony_id%in%hypothetic_virus_first),"first_source_discovered_RAND"] <- "virus"
### for Nb: copy status column into a new column status_RAND, and switch the values for those colonies who have been assigned a different first source discovered than in the observed data
rand_subset_Nb$status_RAND  <- rand_subset_Nb$status                                                                           <- rand_subset_Nb$status
rand_subset_Nb[which(rand_subset_Nb$first_source_discovered_RAND!=rand_subset_Nb$first_source_discovered &  rand_subset_Nb$status=="virus"),"status_RAND"] <- "healthy"
rand_subset_Nb[which(rand_subset_Nb$first_source_discovered_RAND!=rand_subset_Nb$first_source_discovered &  rand_subset_Nb$status=="healthy"),"status_RAND"] <- "virus"
### for Diff: multiply the rows of colonies who have been assigned a different first source discovered than in the observed data by minus 1
rand_subset_Diff[which(rand_subset_Diff$first_source_discovered_RAND!=rand_subset_Diff$first_source_discovered),"Delta_Nb_ants"] <- (-1)*rand_subset_Diff[which(rand_subset_Diff$first_source_discovered_RAND!=rand_subset_Diff$first_source_discovered),"Delta_Nb_ants"]
### concatenate and store
rand_Nb   <- rbind(rand_Nb  ,data.frame(RAND=i, feeding_session=session, rand_subset_Nb))
rand_Diff <- rbind(rand_Diff,data.frame(RAND=i, feeding_session=session, rand_subset_Diff))
}
### then we use aggregate to get the mean number of ants at each time point in the hypothetical scenario, across all colonies and both feeding events
mean_rand_dat_Nb <- aggregate(Nb_ants ~ status_RAND + time, FUN=mean, data=rand_Nb)
### and we use aggregate to calculate the mean delta nb ant across all times,  all colonies and both feeding events in the hypothetical scenario
mean_rand_dat_Diff <- aggregate(Delta_Nb_ants ~  1, FUN=mean, data=rand_Diff)
### and we concatenate
random_data_dynamic_Nb <- rbind(random_data_dynamic_Nb,data.frame(RAND=i, feeding_session=session, mean_rand_dat_Nb))
random_data_Diff       <- rbind(random_data_Diff      ,data.frame(RAND=i, feeding_session=session, mean_rand_dat_Diff))
}
### Plot expected vs observed, Delta ants
xmin <- min (c(random_data_Diff$Delta_Nb_ants),observed_Diff[,"Delta_Nb_ants"])
xmax <- max (c(random_data_Diff$Delta_Nb_ants),observed_Diff[,"Delta_Nb_ants"])
hist(random_data_Diff$Delta_Nb_ants,col=alpha("grey",0.5),xlim=c(xmin,xmax),main=paste("Observed vs Expected,",capitalize(time_origin),"T0"), xlab=expression(paste(Delta, " number of ants")))
arrows(x0=observed_Diff[,"Delta_Nb_ants"],
y0=0,
y1=-10,
code=1,
col="black",
lwd=4,
length=0.1)
### P value
if (observed_Diff[,"Delta_Nb_ants"]>median(random_data_Diff$Delta_Nb_ants)){
pval <- 2*length(which(random_data_Diff$Delta_Nb_ants>=observed_Diff[,"Delta_Nb_ants"]))/length(random_data_Diff$Delta_Nb_ants)
mtext(paste("p=",pval),3, cex = 1.3)
}else{
pval <- 2*length(which(random_data_Diff$Delta_Nb_ants<=observed_Diff[,"Delta_Nb_ants"]))/length(random_data_Diff$Delta_Nb_ants)
mtext(paste("p=",pval),3, cex = 1.3)
}
}
}
# get duration in seconds:
dat_duration <- dat_duration %>%
mutate(feeding_duration_seconds = as.numeric(as.difftime(feeding_duration, format="%H:%M:%S", units="secs")))
# get correct position of virus and data from other numbers data frame
# create new variable food source saying for each of the feeding events whether it was no a virus of control food source
for (i in 1:nrow(dat_duration)) { # i <- 1
index <- which(dat_numbers$colony_id == dat_duration$colony_id[i] &
dat_numbers$feeding_session == dat_duration$feeding_session[i])
dat_duration$position_virus[i] <- dat_numbers$position_virus_corrected[index]
dat_duration$treatment[i]      <- dat_numbers$treatment[index]
if (dat_duration$feeding_side[i] == "r") { # get the side at which the feeding event was observed
mapped_feeding_side <- "right"
} else if (dat_duration$feeding_side[i] == "l") {
mapped_feeding_side <- "left"
} else {
mapped_feeding_side <- NA
}
if (mapped_feeding_side == dat_numbers$position_virus_corrected[index]) { #define whether feeding event occured on a virus or control food source
dat_duration$food_source[i] <- "virus"
} else {
dat_duration$food_source[i] <- "control"
}
}
# mean duration of feeding  events based on the two food sources just for the first 5 events per food source
# subset based on event_id (for each event a number saying this was feeding nr X on this food source for left or right)
dat_duration <- dat_duration %>% # extract the number from event_id for new variable
mutate(event_number = as.numeric(gsub("^[^0-9]*(\\d+).*", "\\1", event_id))) %>%
filter(!is.na(event_number))
dat_duration_sub <- subset(dat_duration, event_number <= 5 )
dat_duration_sub %>%
group_by(food_source) %>%
summarize(
mean_feeding_duration = mean(feeding_duration_seconds, na.rm = TRUE),
sd_feeding_duration = sd(feeding_duration_seconds, na.rm = TRUE)
)
# Arrange data and run test
mean_feeding_duration <- dat_duration_sub %>%
group_by(colony_id, feeding_session, food_source) %>%
summarise(mean_duration = mean(feeding_duration_seconds, na.rm = TRUE)) %>%
ungroup()
wide_data <- mean_feeding_duration %>%
pivot_wider(names_from = c(feeding_session, food_source), values_from = mean_duration)
friedman_data <- as.matrix(wide_data[,-1]) # turn into matrix without id column
friedman.test(friedman_data)
### Plot
ggplot(dat_duration_sub, aes(x = food_source, y = feeding_duration_seconds, fill = food_source)) +
geom_boxplot(outlier.shape = NA) +
geom_jitter(width = 0.35, color = "black", alpha = 0.1) +
labs(
title = "Feeding Duration by Food Source (first 5 events only)",
x = "Food Source",
y = "Feeding Duration (seconds)"
) +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
scale_fill_manual(values = c("virus" = "#FBB4AE", "control" = "#CCEBC5")) +
geom_segment(aes(x = 1, xend = 2, y = 1.05 * max(dat_duration_sub$feeding_duration_seconds, na.rm = TRUE),
yend = 1.05 * max(dat_duration_sub$feeding_duration_seconds, na.rm = TRUE)),
color = "black", size = 0.25) +
annotate("text", x = 1.5, y = 1.1 * max(dat_duration_sub$feeding_duration_seconds, na.rm = TRUE),
label = "p = 0.54 (Friedmann test)", color = "black", size = 3)
dat_duration_first <- subset(dat_duration, feeding_session == 1)
dat_duration_first$feeding_duration_seconds_capped <- dat_duration_first
# condiser capping any feeding event longer than 5 minutes:
cap_threshold <- 5 * 60  # capping threshold in seconds
dat_duration_first$feeding_duration_seconds_capped <- ifelse(
dat_duration_first$feeding_duration_seconds > cap_threshold,
cap_threshold,
dat_duration_first$feeding_duration_seconds)
mod <- glmer(feeding_duration_seconds ~ food_source + (1|colony_id) + (1|block), data = dat_duration_first, family = "poisson")
summary(mod)
Anova(mod)
residuals_poisson <- residuals(mod, type = "pearson")
test_norm(residuals_poisson) # not ok, but not needed for poisson
# Non-Normal Residuals: For Poisson models, residuals are not expected to be normally distributed. The Poisson distribution is skewed, especially for small means.
# Alternative checks suitable for this:
# Over dispersion
overdispersion <- sum(residuals_poisson^2) / df.residual(mod)
print(overdispersion) # should be around 1 (otherwise the model underestimates variability) which it is not --> so the data is overdispersed which needs to be addressed.
#' Possible Solutions:
#' Negative Binomial Regression: Use a negative binomial model instead of a Poisson model, which includes an extra parameter to account for overdispersion.
#' Quasi-Poisson Model: Use a quasi-Poisson model, which adjusts the standard errors to account for overdispersion.
#' Additional Random Effects: Adding more random effects or accounting for hierarchical structures in your data might help.
# Fit a negative binomial GLMM
mod_nb <- glmmTMB(feeding_duration_seconds ~ food_source + (1|colony_id) + (1|block),
data = dat_duration_first, family = nbinom2)
summary(mod_nb)
# Check for overdispersion
overdisp_fun <- function(model) {
rdf <- df.residual(model)
rp <- residuals(model, type = "pearson")
Pearson.chisq <- sum(rp^2)
prat <- Pearson.chisq / rdf
pval <- pchisq(Pearson.chisq, df = rdf, lower.tail = FALSE)
c(chisq = Pearson.chisq, ratio = prat, rdf = rdf, p = pval)
}
overdisp_fun(mod_nb) # close to 1 and thus the model handles over dispersion adequately
### Plot
ggplot(dat_duration_first, aes(x = food_source, y = feeding_duration_seconds_capped, fill = food_source)) +
geom_boxplot(outlier.shape = NA) +
geom_jitter(width = 0.35, color = "black", alpha = 0.1) +
labs(title = "Feeding Duration by Food Source",
x = "Food Source",
y = "Feeding Duration (seconds)") +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
scale_fill_manual(values = c("virus" = "#FBB4AE", "control" = "#CCEBC5")) +
geom_segment(aes(x = 1, xend = 2, y = 1.05 * max(feeding_duration_seconds_capped, na.rm = TRUE),
yend = 1.05 * max(feeding_duration_seconds_capped, na.rm = TRUE)),
color = "black", size = 0.25) +
annotate("text", x = 1.5, y = 1.1 * max(dat_duration_first$feeding_duration_seconds_capped, na.rm = TRUE),
label = "*** (glmer nbinom2)", color = "black", size = 3)
dat_summary <- dat_duration_first %>%
group_by(food_source, colony_id) %>%
summarise(
num_feeding_events = n(),
total_feeding_duration = sum(feeding_duration_seconds, na.rm = TRUE)
) %>% as.data.frame()
# number of feeding events per colony per food source
mod <- lmer(num_feeding_events ~ food_source + (1|colony_id) , data = dat_summary)
summary(mod)
Anova(mod)
compareqqnorm(mod); par(mfrow = c(1,1))
aov_residuals <- residuals(object = mod)
shapiro.test(x = aov_residuals) #not significant --> good
ggplot(dat_summary, aes(x = food_source, y = num_feeding_events, fill = food_source)) +
geom_boxplot() +
geom_jitter(width = 0.2, color = "black", alpha = 0.2) +
labs(title = "Number of Feeding Events",
x = "Food Source",
y = "Number of Feeding Events") +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
scale_fill_manual(values = c("virus" = "#FBB4AE", "control" = "#CCEBC5")) +
geom_segment(aes(x = 1, xend = 2, y = 1.05 * max(num_feeding_events, na.rm = TRUE),
yend = 1.05 * max(num_feeding_events, na.rm = TRUE)),
color = "black", size = 0.25) +
annotate("text", x = 1.5, y = 1.1 * max(dat_summary$num_feeding_events, na.rm = TRUE),
label = "p = 0.054 (lmer)", color = "black", size = 3)
# summed up feeding duration per colony and food source
mod <- lmer(log10(total_feeding_duration) ~ food_source + (1|colony_id) , data = dat_summary)
summary(mod)
Anova(mod)
compareqqnorm(mod)
aov_residuals <- residuals(object = mod)
shapiro.test(x = aov_residuals) # not significant good
ggplot(dat_summary, aes(x = food_source, y = total_feeding_duration, fill = food_source)) +
geom_boxplot() +
geom_jitter(width = 0.2, color = "black", alpha = 0.2) +
labs(title = "Summed up Duration of Feeding Events per Colony",
x = "Food Source",
y = "Duration of Feeding Events in Seconds") +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank())+
scale_fill_manual(values = c("virus" = "#FBB4AE", "control" = "#CCEBC5")) +
geom_segment(aes(x = 1, xend = 2, y = 1.05 * max(total_feeding_duration, na.rm = TRUE),
yend = 1.05 * max(total_feeding_duration, na.rm = TRUE)),
color = "black", size = 0.25) +
annotate("text", x = 1.5, y = 1.1 * max(dat_summary$total_feeding_duration, na.rm = TRUE),
label = "p = 0.0008 (lmer)", color = "black", size = 3)
# create a full grid with seconds, food_source and colonies and add in the the original data:
dat_duration_first$feeding_start_seconds <- period_to_seconds(hms(dat_duration_first$feeding_start))
dat_duration_first$feeding_end_seconds <- dat_duration_first$feeding_start_seconds + dat_duration_first$feeding_duration_seconds_capped
# run the below for shifted or non shifted time points....
for (start_time in c("start_experiment", "shifted_discovery")) { # could also include discovery of first food but has been removed to save time: "discovery_first_food",
if (start_time == "start_experiment") {
subsetted_data <- dat_duration_first
}
if (start_time == "shifted_discovery") {
summary_time_first_feeding <- dat_duration_first %>% group_by(colony_id, food_source) %>%
summarize(time_first_feeding = min(feeding_start_seconds, na.rm = TRUE)) %>% ungroup() %>% as.data.frame()
subsetted_data <- dat_duration_first %>% left_join(summary_time_first_feeding, by = c("colony_id", "food_source"))
# filter to only include feeding events starting within the 60 min (3600s) window since discovery (first actual feeding) of the food source of interest (different discovery times)
subsetted_data <- subsetted_data %>%
mutate(feeding_start_seconds = feeding_start_seconds - time_first_feeding) %>%
mutate(feeding_end_seconds = feeding_end_seconds - time_first_feeding) %>%
filter(feeding_start_seconds >= 0 & feeding_start_seconds <= 3600)
}
if (start_time == "discovery_first_food") {
summary_time_first_feeding <- dat_duration_first %>% group_by(colony_id) %>%
summarize(time_first_feeding = min(feeding_start_seconds, na.rm = TRUE)) %>% ungroup() %>% as.data.frame()
subsetted_data <- dat_duration_first %>% left_join(summary_time_first_feeding, by = c("colony_id"))
# filter to only include first hour since discovery of first food.
subsetted_data <- subsetted_data %>%
mutate(feeding_start_seconds = feeding_start_seconds - time_first_feeding) %>%
mutate(feeding_end_seconds = feeding_end_seconds - time_first_feeding) %>%
filter(feeding_start_seconds >= 0 & feeding_start_seconds <= 3600)
}
grid <- expand_grid(
colony_id = unique(subsetted_data$colony_id),
food_source = unique(subsetted_data$food_source),
time = seq(0, max(subsetted_data$feeding_end_seconds, na.rm = TRUE))
) %>% as.data.frame()
cumulative_explotation_over_time <- NULL
# loop over colony_id and food_source
for (colony in unique(grid$colony_id)) {
for (food in unique(grid$food_source)) {
# filter grid and feeding data for the current colony and food source
current_grid <- grid %>% filter(colony_id == colony, food_source == food)
current_feedings <- subsetted_data %>% filter(colony_id == colony, food_source == food)
# compute across all rows of current_grid using vectorized operations
if (nrow(current_feedings) > 0) {
current_feedings <- current_feedings %>% arrange(feeding_start_seconds) # Sort by start time
current_grid <- current_grid %>%
rowwise() %>%
mutate(
cumulated_exploitation_time = sum(
pmin(current_feedings$feeding_duration_seconds,
pmax(0, time - current_feedings$feeding_start_seconds))
),
exploitation_rate = sum(
time >= current_feedings$feeding_start_seconds &
time <= current_feedings$feeding_end_seconds
)
)
} else {
current_grid <- current_grid %>%
mutate(cumulated_exploitation_time = 0,
exploitation_rate = 0)
}
cumulative_explotation_over_time <- bind_rows(cumulative_explotation_over_time, current_grid) # append to cumulative_exploitation_over_time
}
}
# aggregate data and calculate means of duration for plotting
mean_exploitation_time <- cumulative_explotation_over_time %>%
group_by(time, food_source) %>%
summarize(mean_time = mean(cumulated_exploitation_time, na.rm = TRUE),
sd = sd(cumulated_exploitation_time, na.rm = TRUE),
sem = sem(cumulated_exploitation_time))
print(
ggplot(mean_exploitation_time, aes(x = time, y = mean_time, color = food_source)) +
geom_line(size = 1) +
geom_ribbon(aes(ymin = mean_time - sem, ymax = mean_time + sem, fill = food_source), alpha = 0.2) +
labs(
title = "Mean Cumulative Exploitation of Food Sources Over Time",
x = "Time",
y = "Mean Cumulated Exploitation Time (seconds)") +
scale_color_manual(values = c("virus" = "#FBB4AE", "control" = "#CCEBC5")) +
theme_bw() +
theme(legend.title = element_blank())+
theme(legend.title = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
)
# aggregate data and calculate means of exploitation rate for plotting
mean_exploitation_rate <- cumulative_explotation_over_time %>%
group_by(time, food_source) %>%
summarize(mean_exploitation = mean(exploitation_rate, na.rm = TRUE),
sd = sd(exploitation_rate, na.rm = TRUE))
# plot
print(
ggplot(mean_exploitation_rate, aes(x = time, y = mean_exploitation, color = food_source)) +
geom_line(size = 1) +
labs(
title = "Mean Cumulative Exploitation of Food Sources Over Time",
x = "Time",
y = "Mean Cumulated Exploitation Time (seconds)") +
scale_color_manual(values = c("virus" = "#FBB4AE", "control" = "#CCEBC5")) +
theme_bw() +
theme(legend.title = element_blank())+
theme(legend.title = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
)
}
start_time
cumulative_explotation_over_time
cumulative_explotation_over_time
mod <- lmer(cumulated_exploitation_time ~ food_source*time + (1|colony_id), data = cumulative_explotation_over_time)
car::Anova(mod, type=3)
summary(mod)
data_predic <- cumulative_explotation_over_time
names(data_predic)
time_range <- max(data_predic$time)-min(data_predic$time)
time_range
seq(min(data_predic$time) - 0.05*time_range, max(data_predic$time) + 0.05*time_range, length.out = 100)
time_range
seq(min(data_predic$time), max(data_predic$time), length.out = 100)
new_dat <- expand.grid(
time = seq(min(data_predic$time), max(data_predic$time), length.out = 100),
# time = seq(min(data_predic$time) - 0.05*time_range, max(data_predic$time) + 0.05*time_range, length.out = 100),
food_source = unique(data_predic$food_source)
)
length(data_predic$time)
length(new_dat$time)
names(data_predic)
new_dat$cum_exploitation <- predict(mod, new_dat, re.form = NA)
new_dat$cum_exploitation
new_dat
mm <- model.matrix(terms(mod),new_dat)
terms(mod)
new_dat <- expand.grid(
time = seq(min(data_predic$time), max(data_predic$time), length.out = 100),
# time = seq(min(data_predic$time) - 0.05*time_range, max(data_predic$time) + 0.05*time_range, length.out = 100),
food_source = unique(data_predic$food_source)
)
new_dat$cumulated_exploitation_time <- predict(mod, new_dat, re.form = NA)
mm <- model.matrix(terms(mod),new_dat)
mm
pvar1 <- diag(mm %*% tcrossprod(vcov(mod),mm))
pvar1
cmult <- 1.96 ## could use 1.96
new_dat <- data.frame(
new_dat,
ci_lo = new_dat$cumulated_exploitation_time - cmult * sqrt(pvar1),
ci_hi = new_dat$cumulated_exploitation_time + cmult * sqrt(pvar1),
se_lo = new_dat$cumulated_exploitation_time - sqrt(pvar1),
se_hi = new_dat$cumulated_exploitation_time + sqrt(pvar1)
)
new_dat_control     <- new_dat[which(new_dat$food_source == "control"),]
new_dat_virus       <- new_dat[which(new_dat$food_source == "virus"  ),]
data_predict$food_source
data_predic$food_source
data_predic$food_source <- factor(data_predic$food_source, levels = c("control", "virus"))
# Define colors and other graphical parameters
col_control <- "#1f77b4"  # Blue for control
col_virus <- "#ff7f0e"    # Orange for virus
linwidth <- 1.2           # Line width
alpha <- 0.6              # Transparency for points
pointsize <- 2.5          # Size for points
linalpha <- 0.2           # Transparency for ribbons
# Plotting
p_cum_exploitation <- ggplot(data = cumulative_explotation_over_time, aes(x = time, y = cumulated_exploitation_time)) +
# Add ribbons for standard error ranges (optional, uncomment if needed)
geom_ribbon(data = new_dat_control, aes(ymin = se_lo, ymax = se_hi), fill = alpha(col_control, linalpha), color = NA) +
geom_ribbon(data = new_dat_virus, aes(ymin = se_lo, ymax = se_hi), fill = alpha(col_virus, linalpha), color = NA) +
# Add lines for predicted values
geom_line(data = new_dat_control, aes(y = cumulated_exploitation_time), size = linwidth, color = col_control) +
geom_line(data = new_dat_virus, aes(y = cumulated_exploitation_time), size = linwidth, color = col_virus) +
# Add points for observed data
geom_point(alpha = alpha, size = pointsize, position = position_jitterdodge(jitter.width = 4.2, dodge.width = 9),
aes(group = food_source, color = food_source)) +
# Customize axes
scale_x_continuous(breaks = c(0, 24, 48, 72, 144)) +
xlab("Time (hours)") +
ylab("Cumulated Exploitation Time") +
# Customize colors
scale_color_manual(values = c("control" = col_control, "virus" = col_virus))
# Print the plot
print(p_cum_exploitation)
# Plotting
p_cum_exploitation <- ggplot(data = cumulative_explotation_over_time, aes(x = time, y = cumulated_exploitation_time)) +
# Add ribbons for standard error ranges (optional, uncomment if needed)
geom_ribbon(data = new_dat_control, aes(ymin = se_lo, ymax = se_hi), fill = alpha(col_control, linalpha), color = NA) +
geom_ribbon(data = new_dat_virus, aes(ymin = se_lo, ymax = se_hi), fill = alpha(col_virus, linalpha), color = NA) +
# Add lines for predicted values
geom_line(data = new_dat_control, aes(y = cumulated_exploitation_time), size = linwidth, color = col_control) +
geom_line(data = new_dat_virus, aes(y = cumulated_exploitation_time), size = linwidth, color = col_virus) +
# Add points for observed data
#geom_point(alpha = alpha, size = pointsize, position = position_jitterdodge(jitter.width = 4.2, dodge.width = 9),
#           aes(group = food_source, color = food_source)) +
# Customize axes
scale_x_continuous(breaks = c(0, 24, 48, 72, 144)) +
xlab("Time (hours)") +
ylab("Cumulated Exploitation Time") +
# Customize colors
scale_color_manual(values = c("control" = col_control, "virus" = col_virus))
# Print the plot
print(p_cum_exploitation)
